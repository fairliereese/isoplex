{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to isoplex's documentation!","text":"<p>This library implements the basic computations described by Schertzer et al. in their manuscript. In brief, from a counts or TPM expression matrix of transcriptome features (transcript isoforms, ORF ids, protein IDs, etc) and their associated genes, <code>isoplex</code> will compute the gene potential, entropy, perplexity, and mark effective features based on the aforementioned metrics.</p> <p>These metrics are designed to provide a more intuitive description of isoform diversity as well as to provide a less rigid framework for filtering isoforms, as the distribution of expression values are taken into account for each gene to mark isoforms as effective or not, rather than applying a uniform filter across the entire dataset.</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Installation</li> <li>Usage</li> <li>Input data formatting</li> <li>API</li> <li>Contributing</li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant 3.0","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We pledge to make our community welcoming, safe, and equitable for all.</p> <p>We are committed to fostering an environment that respects and promotes the dignity, rights, and contributions of all individuals, regardless of characteristics including race, ethnicity, caste, color, age, physical characteristics, neurodiversity, disability, sex or gender, gender identity or expression, sexual orientation, language, philosophy or religion, national or social origin, socio-economic position, level of education, or other status. The same privileges of participation are extended to everyone who participates in good faith and in accordance with this Covenant.</p>"},{"location":"CODE_OF_CONDUCT/#encouraged-behaviors","title":"Encouraged Behaviors","text":"<p>While acknowledging differences in social norms, we all strive to meet our community's expectations for positive behavior. We also understand that our words and actions may be interpreted differently than we intend based on culture, background, or native language.</p> <p>With these considerations in mind, we agree to behave mindfully toward each other and act in ways that center our shared values, including:</p> <ol> <li>Respecting the purpose of our community, our activities, and our ways of gathering.</li> <li>Engaging kindly and honestly with others.</li> <li>Respecting different viewpoints and experiences.</li> <li>Taking responsibility for our actions and contributions.</li> <li>Gracefully giving and accepting constructive feedback.</li> <li>Committing to repairing harm when it occurs.</li> <li>Behaving in other ways that promote and sustain the well-being of our community.</li> </ol>"},{"location":"CODE_OF_CONDUCT/#restricted-behaviors","title":"Restricted Behaviors","text":"<p>We agree to restrict the following behaviors in our community. Instances, threats, and promotion of these behaviors are violations of this Code of Conduct.</p> <ol> <li>Harassment. Violating explicitly expressed boundaries or engaging in unnecessary personal attention after any clear request to stop.</li> <li>Character attacks. Making insulting, demeaning, or pejorative comments directed at a community member or group of people.</li> <li>Stereotyping or discrimination. Characterizing anyone\u2019s personality or behavior on the basis of immutable identities or traits.</li> <li>Sexualization. Behaving in a way that would generally be considered inappropriately intimate in the context or purpose of the community.</li> <li>Violating confidentiality. Sharing or acting on someone's personal or private information without their permission.</li> <li>Endangerment. Causing, encouraging, or threatening violence or other harm toward any person or group.</li> <li>Behaving in other ways that threaten the well-being of our community.</li> </ol>"},{"location":"CODE_OF_CONDUCT/#other-restrictions","title":"Other Restrictions","text":"<ol> <li>Misleading identity. Impersonating someone else for any reason, or pretending to be someone else to evade enforcement actions.</li> <li>Failing to credit sources. Not properly crediting the sources of content you contribute.</li> <li>Promotional materials. Sharing marketing or other commercial content in a way that is outside the norms of the community.</li> <li>Irresponsible communication. Failing to responsibly present content which includes, links or describes any other restricted behaviors.</li> </ol>"},{"location":"CODE_OF_CONDUCT/#reporting-an-issue","title":"Reporting an Issue","text":"<p>Tensions can occur between community members even when they are trying their best to collaborate. Not every conflict represents a code of conduct violation, and this Code of Conduct reinforces encouraged behaviors and norms that can help avoid conflicts and minimize harm.</p> <p>When an incident does occur, it is important to report it promptly. To report a possible violation, email fairlie.reese@gmail.com.</p> <p>Community Moderators take reports of violations seriously and will make every effort to respond in a timely manner. They will investigate all reports of code of conduct violations, reviewing messages, logs, and recordings, or interviewing witnesses and other participants. Community Moderators will keep investigation and enforcement actions as transparent as possible while prioritizing safety and confidentiality. In order to honor these values, enforcement actions are carried out in private with the involved parties, but communicating to the whole community may be part of a mutually agreed upon resolution.</p>"},{"location":"CODE_OF_CONDUCT/#addressing-and-repairing-harm","title":"Addressing and Repairing Harm","text":"<p>If an investigation by the Community Moderators finds that this Code of Conduct has been violated, the following enforcement ladder may be used to determine how best to repair harm, based on the incident's impact on the individuals involved and the community as a whole. Depending on the severity of a violation, lower rungs on the ladder may be skipped.</p> <p>1) Warning    1) Event: A violation involving a single incident or series of incidents.    2) Consequence: A private, written warning from the Community Moderators.    3) Repair: Examples of repair include a private written apology, acknowledgement of responsibility, and seeking clarification on expectations. 2) Temporarily Limited Activities    1) Event: A repeated incidence of a violation that previously resulted in a warning, or the first incidence of a more serious violation.    2) Consequence: A private, written warning with a time-limited cooldown period designed to underscore the seriousness of the situation and give the community members involved time to process the incident. The cooldown period may be limited to particular communication channels or interactions with particular community members.    3) Repair: Examples of repair may include making an apology, using the cooldown period to reflect on actions and impact, and being thoughtful about re-entering community spaces after the period is over. 3) Temporary Suspension    1) Event: A pattern of repeated violation which the Community Moderators have tried to address with warnings, or a single serious violation.    2) Consequence: A private written warning with conditions for return from suspension. In general, temporary suspensions give the person being suspended time to reflect upon their behavior and possible corrective actions.    3) Repair: Examples of repair include respecting the spirit of the suspension, meeting the specified conditions for return, and being thoughtful about how to reintegrate with the community when the suspension is lifted. 4) Permanent Ban    1) Event: A pattern of repeated code of conduct violations that other steps on the ladder have failed to resolve, or a violation so serious that the Community Moderators determine there is no way to keep the community safe with this person as a member.    2) Consequence: Access to all community spaces, tools, and communication channels is removed. In general, permanent bans should be rarely used, should have strong reasoning behind them, and should only be resorted to if working through other remedies has failed to change the behavior.    3) Repair: There is no possible repair in cases of this severity.</p> <p>This enforcement ladder is intended as a guideline. It does not limit the ability of Community Managers to use their discretion and judgment, in keeping with the best interests of our community.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public or other spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 3.0, permanently available at https://www.contributor-covenant.org/version/3/0/.</p> <p>Contributor Covenant is stewarded by the Organization for Ethical Source and licensed under CC BY-SA 4.0. To view a copy of this license, visit https://creativecommons.org/licenses/by-sa/4.0/</p> <p>For answers to common questions about Contributor Covenant, see the FAQ at https://www.contributor-covenant.org/faq. Translations are provided at https://www.contributor-covenant.org/translations. Additional enforcement and community guideline resources can be found at https://www.contributor-covenant.org/resources. The enforcement ladder was inspired by the work of Mozilla\u2019s code of conduct team.</p>"},{"location":"api/","title":"API Reference","text":"<p>Top-level package for Isoform Perplexity.</p>"},{"location":"api/#isoplex.call_effective","title":"<code>call_effective(df, gene_col=GENE_COL, feature_col=TRANSCRIPT_COL)</code>","text":"<p>Identify effective features per gene based on gene perplexity.</p>"},{"location":"api/#isoplex.call_effective--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     DataFrame containing gene, feature, 'pi', and 'perplexity' columns. gene_col : str     Column representing the gene (default: 'gene_id') feature_col : str     Column representing the feature (default: 'transcript_id')</p>"},{"location":"api/#isoplex.call_effective--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame with additional columns:     - 'n_effective': perplexity rounded to nearest integer     - 'feature_rank': rank of each feature within its gene (by pi)     - 'effective': boolean indicating if feature is effective</p> Source code in <code>src/isoplex/utils.py</code> <pre><code>def call_effective(df, gene_col=GENE_COL, feature_col=TRANSCRIPT_COL):\n    \"\"\"\n    Identify effective features per gene based on gene perplexity.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame containing gene, feature, 'pi', and 'perplexity' columns.\n    gene_col : str\n        Column representing the gene (default: 'gene_id')\n    feature_col : str\n        Column representing the feature (default: 'transcript_id')\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with additional columns:\n        - 'n_effective': perplexity rounded to nearest integer\n        - 'feature_rank': rank of each feature within its gene (by pi)\n        - 'effective': boolean indicating if feature is effective\n    \"\"\"\n    # round perplexity to nearest integer\n    df['n_effective'] = df['perplexity'].round(0)\n\n    # rank features within each gene by pi\n    df['feature_rank'] = (\n        df.groupby(gene_col)['pi']\n        .rank(method='first', ascending=False)\n        .astype(int)\n    )\n\n    # mark features as effective if rank &lt;= rounded perplexity\n    df['effective'] = df['feature_rank'] &lt;= df['n_effective']\n\n    return df\n</code></pre>"},{"location":"api/#isoplex.collapse_counts_by_feature","title":"<code>collapse_counts_by_feature(df, feature_col=TRANSCRIPT_COL, expression_type=EXP_COL, gene_col=GENE_COL, sample_col=None)</code>","text":"<p>Collapse counts by a feature (e.g. ORF, transcript) instead of transcript.</p>"},{"location":"api/#isoplex.collapse_counts_by_feature--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     Input table with counts at transcript level. feature_col : str     Alternative feature column to collapse to (e.g. 'orf_id'). expression_type : str     Name of expression col to collapse gene_col : str     Column identifying genes. sample_col : str, optional     Sample column. If None, assumes single-sample bulk.</p>"},{"location":"api/#isoplex.collapse_counts_by_feature--returns","title":"Returns","text":"<p>pd.DataFrame     Collapsed df with summed counts per feature.</p> Source code in <code>src/isoplex/utils.py</code> <pre><code>def collapse_counts_by_feature(df,\n                               feature_col=TRANSCRIPT_COL,\n                               expression_type=EXP_COL,\n                               gene_col=GENE_COL,\n                               sample_col=None):\n    \"\"\"\n    Collapse counts by a feature (e.g. ORF, transcript) instead of transcript.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Input table with counts at transcript level.\n    feature_col : str\n        Alternative feature column to collapse to (e.g. 'orf_id').\n    expression_type : str\n        Name of expression col to collapse\n    gene_col : str\n        Column identifying genes.\n    sample_col : str, optional\n        Sample column. If None, assumes single-sample bulk.\n\n    Returns\n    -------\n    pd.DataFrame\n        Collapsed df with summed counts per feature.\n    \"\"\"\n    group_cols = list(dict.fromkeys([gene_col, feature_col]))\n\n    if sample_col is not None:\n        group_cols.append(sample_col)\n\n    # sum counts for all transcripts mapping to the same feature\n    out = (df.groupby(group_cols, as_index=False)[expression_type]\n          .sum())\n\n    return out\n</code></pre>"},{"location":"api/#isoplex.compute_avg_expression","title":"<code>compute_avg_expression(df, sample_col, feature_col=TRANSCRIPT_COL)</code>","text":"<p>Compute average expression across samples for each feature. Only considers samples where feature is expressed!</p>"},{"location":"api/#isoplex.compute_avg_expression--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     DataFrame containing feature, sample, and counts columns. sample_col : str     Column representing sample IDs. feature_col : str     Column representing the feature (default: 'transcript_id')</p>"},{"location":"api/#isoplex.compute_avg_expression--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame with additional column:     - 'avg__tpm': mean tpm across samples for the feature Source code in <code>src/isoplex/utils.py</code> <pre><code>def compute_avg_expression(df, sample_col, feature_col=TRANSCRIPT_COL):\n    \"\"\"\n    Compute average expression across samples for each feature.\n    Only considers samples where feature is expressed!\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame containing feature, sample, and counts columns.\n    sample_col : str\n        Column representing sample IDs.\n    feature_col : str\n        Column representing the feature (default: 'transcript_id')\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with additional column:\n        - 'avg_&lt;feature_col&gt;_tpm': mean tpm across samples for the feature\n    \"\"\"\n    temp = df[[feature_col, sample_col, 'tpm']]\n\n    # filter out unexpressed features so mean denominator is correct\n    temp = temp.loc[temp['tpm'] &gt; 0]\n\n    # sum counts per feature per sample (handles cases with multiple rows per feature)\n    temp = (\n        temp.groupby([feature_col, sample_col])\n        .sum()\n        .reset_index()\n        .rename({'tpm': f'{feature_col}_tpm'}, axis=1)\n    )\n    temp.drop(sample_col, axis=1, inplace=True)\n\n    # then take mean across samples\n    temp = (\n        temp.groupby(feature_col)\n        .mean()\n        .reset_index()\n        .rename({f'{feature_col}_tpm': f'avg_{feature_col}_tpm'}, axis=1)\n    )\n\n    # merge back to original df\n    df = df.merge(temp, how='left', on=[feature_col])\n\n    return df\n</code></pre>"},{"location":"api/#isoplex.compute_entropy","title":"<code>compute_entropy(df, gene_col=GENE_COL)</code>","text":"<p>Compute Shannon entropy per gene based on isoform proportions.</p>"},{"location":"api/#isoplex.compute_entropy--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     DataFrame containing gene and 'pi' columns. gene_col : str     Column representing the gene (default: 'gene_id')</p>"},{"location":"api/#isoplex.compute_entropy--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame with an additional column:     - 'entropy': Shannon entropy per gene</p> Source code in <code>src/isoplex/utils.py</code> <pre><code>def compute_entropy(df, gene_col=GENE_COL):\n    \"\"\"\n    Compute Shannon entropy per gene based on isoform proportions.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame containing gene and 'pi' columns.\n    gene_col : str\n        Column representing the gene (default: 'gene_id')\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with an additional column:\n        - 'entropy': Shannon entropy per gene\n    \"\"\"\n    # compute plogp for each feature; avoid log2(0)\n    df['plogp'] = df['pi'] * np.log2(df['pi'].replace(0, np.nan))\n\n    # sum plogp per gene\n    entropy_df = (\n        df[[gene_col, 'plogp']]\n        .groupby(gene_col)\n        .sum()\n        .reset_index()\n        .rename({'plogp': 'entropy'}, axis=1)\n    )\n\n    # multiply by -1 for positive entropy\n    entropy_df['entropy'] = -1 * entropy_df['entropy']\n\n    # merge back to original df\n    df = df.merge(entropy_df, how='left', on=gene_col)\n\n    # drop intermediate column\n    df = df.drop(columns='plogp')\n\n    return df\n</code></pre>"},{"location":"api/#isoplex.compute_expression_breadth","title":"<code>compute_expression_breadth(df, sample_col, feature_col=TRANSCRIPT_COL)</code>","text":"<p>Compute percentage of samples in which each feature is effective.</p>"},{"location":"api/#isoplex.compute_expression_breadth--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     DataFrame containing feature, sample, and 'effective' columns. sample_col : str     Column representing sample IDs. feature_col : str     Column representing the feature (default: 'transcript_id')</p>"},{"location":"api/#isoplex.compute_expression_breadth--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame with additional columns:     - 'n_samples_effective': number of samples where the feature is effective     - 'expression_breadth': percentage of samples where the feature is effective</p> Source code in <code>src/isoplex/utils.py</code> <pre><code>def compute_expression_breadth(df, sample_col, feature_col=TRANSCRIPT_COL):\n    \"\"\"\n    Compute percentage of samples in which each feature is effective.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame containing feature, sample, and 'effective' columns.\n    sample_col : str\n        Column representing sample IDs.\n    feature_col : str\n        Column representing the feature (default: 'transcript_id')\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with additional columns:\n        - 'n_samples_effective': number of samples where the feature is effective\n        - 'expression_breadth': percentage of samples where the feature is effective\n    \"\"\"\n    n_samples = df[sample_col].nunique()\n\n    temp = (\n        df.loc[df['effective'], [feature_col, sample_col]]\n        .groupby(feature_col)\n        .nunique()\n        .reset_index()\n        .rename({sample_col: 'n_samples_effective'}, axis=1)\n    )\n\n    df = df.merge(temp, how='left', on=feature_col)\n    df['expression_breadth'] = df['n_samples_effective'].fillna(0) / n_samples * 100\n\n    return df\n</code></pre>"},{"location":"api/#isoplex.compute_expression_var","title":"<code>compute_expression_var(df, sample_col, feature_col=TRANSCRIPT_COL)</code>","text":"<p>Compute number of samples expressing each feature and pi standard deviation.</p>"},{"location":"api/#isoplex.compute_expression_var--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     DataFrame containing feature, sample, and 'pi' columns. sample_col : str     Column representing sample IDs. feature_col : str     Column representing the feature (default: 'transcript_id')</p>"},{"location":"api/#isoplex.compute_expression_var--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame with additional columns:     - 'n_exp_samples': number of samples where feature is expressed     - 'expression_var': standard deviation of pi across samples</p> Source code in <code>src/isoplex/utils.py</code> <pre><code>def compute_expression_var(df, sample_col, feature_col=TRANSCRIPT_COL):\n    \"\"\"\n    Compute number of samples expressing each feature and pi standard deviation.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame containing feature, sample, and 'pi' columns.\n    sample_col : str\n        Column representing sample IDs.\n    feature_col : str\n        Column representing the feature (default: 'transcript_id')\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with additional columns:\n        - 'n_exp_samples': number of samples where feature is expressed\n        - 'expression_var': standard deviation of pi across samples\n    \"\"\"\n    # number of samples where feature is expressed\n    df['n_exp_samples'] = df.groupby(feature_col)[sample_col].transform('nunique')\n\n    # standard deviation of pi across samples\n    df['expression_var'] = df.groupby(feature_col)['pi'].transform(lambda x: x.std(ddof=1, skipna=True))\n\n    return df\n</code></pre>"},{"location":"api/#isoplex.compute_global_isoform_metrics","title":"<code>compute_global_isoform_metrics(df, gene_col=GENE_COL, feature_col=TRANSCRIPT_COL, expression_type='counts')</code>","text":"<p>Compute isoform or other feature diversity metrics for a single-sample (bulk) dataframe. Either provide counts or TPMs; if counts, will automatically convert to TPM. Optionally, collapse counts to a different feature or compute TPM.</p>"},{"location":"api/#isoplex.compute_global_isoform_metrics--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     DataFrame containing counts at transcript level. gene_col : str     Column representing the gene (default: 'gene_id') feature_col : str     Column representing the feature (default: 'transcript_id') expression_type : str     Type of expression values in table {'counts' | 'tpm'}</p>"},{"location":"api/#isoplex.compute_global_isoform_metrics--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame with computed metrics.</p> Source code in <code>src/isoplex/utils.py</code> <pre><code>def compute_global_isoform_metrics(df,\n                                   gene_col=GENE_COL,\n                                   feature_col=TRANSCRIPT_COL,\n                                   expression_type='counts'):\n    \"\"\"\n    Compute isoform or other feature diversity metrics for a single-sample (bulk) dataframe.\n    Either provide counts or TPMs; if counts, will automatically convert to TPM.\n    Optionally, collapse counts to a different feature or compute TPM.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame containing counts at transcript level.\n    gene_col : str\n        Column representing the gene (default: 'gene_id')\n    feature_col : str\n        Column representing the feature (default: 'transcript_id')\n    expression_type : str\n        Type of expression values in table {'counts' | 'tpm'}\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with computed metrics.\n    \"\"\"\n    # validate input\n    validate_counts_input(df,\n                          gene_col=gene_col,\n                          feature_col=feature_col)\n\n    # convert from wide to long\n    df = rename_sample_col(df,\n                      gene_col=gene_col,\n                      feature_col=feature_col,\n                      expression_type=expression_type)\n\n    # collapse counts if feature_col is not unique\n    df = collapse_counts_by_feature(df,\n                                    feature_col=feature_col,\n                                    expression_type=expression_type,\n                                    gene_col=gene_col,\n                                    sample_col=None)\n\n    # compute TPM if required\n    df = df if expression_type == 'tpm' else compute_tpm(df)\n\n    # compute isoform ratios\n    df = compute_pi(df, gene_col=gene_col)\n\n    # compute gene-level metrics\n    df = compute_n_detected_features(df, gene_col=gene_col, feature_col=feature_col)\n    df = compute_entropy(df, gene_col=gene_col)\n    df = compute_perplexity(df)\n\n    # mark effective features\n    df = call_effective(df, gene_col=gene_col, feature_col=feature_col)\n\n    return df\n</code></pre>"},{"location":"api/#isoplex.compute_max_expression","title":"<code>compute_max_expression(df, sample_col, feature_col=TRANSCRIPT_COL)</code>","text":"<p>Compute maximum expression across samples for each feature. Only considers samples where feature is expressed!</p>"},{"location":"api/#isoplex.compute_max_expression--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     DataFrame containing feature, sample, and counts columns. sample_col : str     Column representing sample IDs. feature_col : str     Column representing the feature (default: 'transcript_id')</p>"},{"location":"api/#isoplex.compute_max_expression--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame with additional column:     - 'avg__tpm': mean tpm across samples for the feature Source code in <code>src/isoplex/utils.py</code> <pre><code>def compute_max_expression(df, sample_col, feature_col=TRANSCRIPT_COL):\n    \"\"\"\n    Compute maximum expression across samples for each feature.\n    Only considers samples where feature is expressed!\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame containing feature, sample, and counts columns.\n    sample_col : str\n        Column representing sample IDs.\n    feature_col : str\n        Column representing the feature (default: 'transcript_id')\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with additional column:\n        - 'avg_&lt;feature_col&gt;_tpm': mean tpm across samples for the feature\n    \"\"\"\n    temp = df[[feature_col, sample_col, 'tpm']]\n\n    # filter out unexpressed features so mean denominator is correct\n    temp = temp.loc[temp['tpm'] &gt; 0]\n\n    # sum counts per feature per sample (handles cases with multiple rows per feature)\n    temp = (\n        temp.groupby([feature_col, sample_col])\n        .sum()\n        .reset_index()\n        .rename({'tpm': f'{feature_col}_tpm'}, axis=1)\n    )\n    temp.drop(sample_col, axis=1, inplace=True)\n\n    # then take mean across samples\n    temp = (\n        temp.groupby(feature_col)\n        .max()\n        .reset_index()\n        .rename({f'{feature_col}_tpm': f'max_{feature_col}_tpm'}, axis=1)\n    )\n\n    # merge back to original df\n    df = df.merge(temp, how='left', on=[feature_col])\n\n    return df\n</code></pre>"},{"location":"api/#isoplex.compute_multi_sample_isoform_metrics","title":"<code>compute_multi_sample_isoform_metrics(df, gene_col=GENE_COL, feature_col=TRANSCRIPT_COL, expression_type=EXP_COL)</code>","text":"<p>Compute isoform metrics across multiple samples as well as global metrics.</p>"},{"location":"api/#isoplex.compute_multi_sample_isoform_metrics--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     Input table with counts or TPMs for all samples. gene_col : str     Column identifying genes. feature_col : str     Column identifying isoforms or other features (e.g. ORFs). expression_type : {'counts', 'tpm'}     Type of expression values</p>"},{"location":"api/#isoplex.compute_multi_sample_isoform_metrics--returns","title":"Returns","text":"<p>big_df : pd.DataFrame     DataFrame with:       \u2022 per-sample metrics (gene potential, entropy, etc.)       \u2022 cross-sample metrics (breadth, variance, average expression) global_df : pd.DataFrame     DataFrame with:       \u2022 global entropy, detected features, and perplexity per gene,         based on summing tpms across all samples</p> Source code in <code>src/isoplex/utils.py</code> <pre><code>def compute_multi_sample_isoform_metrics(\n    df: pd.DataFrame,\n    gene_col: str = GENE_COL,\n    feature_col: str = TRANSCRIPT_COL,\n    expression_type: str = EXP_COL):\n    \"\"\"\n    Compute isoform metrics across multiple samples as well as global\n    metrics.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Input table with counts or TPMs for all samples.\n    gene_col : str\n        Column identifying genes.\n    feature_col : str\n        Column identifying isoforms or other features (e.g. ORFs).\n    expression_type : {'counts', 'tpm'}\n        Type of expression values\n\n    Returns\n    -------\n    big_df : pd.DataFrame\n        DataFrame with:\n          \u2022 per-sample metrics (gene potential, entropy, etc.)\n          \u2022 cross-sample metrics (breadth, variance, average expression)\n    global_df : pd.DataFrame\n        DataFrame with:\n          \u2022 global entropy, detected features, and perplexity per gene,\n            based on summing tpms across all samples\n    \"\"\"\n\n    # validate input\n    validate_counts_input(df,\n                          gene_col=gene_col,\n                          feature_col=feature_col)\n\n    # prepare kwargs for downstream functions\n    col_kwargs = dict(\n        gene_col=gene_col,\n        feature_col=feature_col,\n        expression_type=expression_type,\n    )\n\n    # loop over samples and compute single-sample metrics\n    samples = [c for c in df.columns if c not in [gene_col, feature_col]]\n    dfs = []\n\n    for i, s in enumerate(samples):\n        s_df = df[[gene_col, feature_col, s]].copy()\n        df.drop(s, axis=1, inplace=True) # remove from original df to save memory\n        # if i % 25 == 0: print(i)\n        s_df = compute_global_isoform_metrics(s_df,\n                                              gene_col=gene_col,\n                                              feature_col=feature_col,\n                                              expression_type=expression_type)\n        s_df['sample'] = s  # re-attach sample ID\n        dfs.append(s_df)\n\n    big_df = pd.concat(dfs, axis=0, ignore_index=True)\n\n    # compute cross-sample metrics on the combined table\n    big_df = compute_expression_breadth(big_df,\n                                        sample_col='sample',\n                                        feature_col=feature_col)\n    big_df = compute_expression_var(big_df,\n                                    sample_col='sample',\n                                    feature_col=feature_col)\n\n    for fc in [feature_col, gene_col]:\n        big_df = compute_avg_expression(big_df,\n                                        sample_col='sample',\n                                        feature_col=fc)\n        big_df = compute_max_expression(big_df,\n                                        sample_col='sample',\n                                        feature_col=fc)\n\n    # sum up tpms across samples\n    global_df = (big_df[[gene_col, feature_col, 'tpm']]\n          .groupby([gene_col, feature_col])\n          .sum()\n          .reset_index()\n         )\n\n    global_df.rename({'tpm': 'global'}, axis=1, inplace=True)\n\n\n\n    global_df = compute_global_isoform_metrics(global_df,\n                                               gene_col=gene_col,\n                                               feature_col=feature_col,\n                                               expression_type='tpm')\n\n    return big_df, global_df\n</code></pre>"},{"location":"api/#isoplex.compute_n_detected_features","title":"<code>compute_n_detected_features(df, gene_col=GENE_COL, feature_col=TRANSCRIPT_COL)</code>","text":"<p>Compute gene potential based on the number of unique expressed features per gene.</p>"},{"location":"api/#isoplex.compute_n_detected_features--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     DataFrame containing gene and feature columns. gene_col : str     Column representing the gene (default: 'gene_id') feature_col : str     Column representing the feature (default: 'transcript_id')</p>"},{"location":"api/#isoplex.compute_n_detected_features--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame with an additional column:     - 'n_detected_features': number of unique features per gene</p> Source code in <code>src/isoplex/utils.py</code> <pre><code>def compute_n_detected_features(df, gene_col=GENE_COL, feature_col=TRANSCRIPT_COL):\n    \"\"\"\n    Compute gene potential based on the number of unique expressed features per gene.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame containing gene and feature columns.\n    gene_col : str\n        Column representing the gene (default: 'gene_id')\n    feature_col : str\n        Column representing the feature (default: 'transcript_id')\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with an additional column:\n        - 'n_detected_features': number of unique features per gene\n    \"\"\"\n    # count unique expressed features per gene\n    temp = df.loc[df.tpm&gt;0].copy(deep=True)\n    n_detected_features_df = (\n        temp[[gene_col, feature_col]]\n        .groupby(gene_col)\n        .nunique()\n        .reset_index()\n        .rename({feature_col: 'n_detected_features'}, axis=1)\n    )\n\n    # merge back to original df\n    df = df.merge(n_detected_features_df, how='left', on=gene_col)\n\n    df['n_detected_features'] = df['n_detected_features'].fillna(0)\n\n    return df\n</code></pre>"},{"location":"api/#isoplex.compute_perplexity","title":"<code>compute_perplexity(df)</code>","text":"<p>Compute perplexity per gene based on Shannon entropy.</p>"},{"location":"api/#isoplex.compute_perplexity--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     DataFrame containing 'gene_id' and 'entropy' columns.</p>"},{"location":"api/#isoplex.compute_perplexity--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame with an additional column:     - 'perplexity': effective number of isoforms per gene</p> Source code in <code>src/isoplex/utils.py</code> <pre><code>def compute_perplexity(df):\n    \"\"\"\n    Compute perplexity per gene based on Shannon entropy.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame containing 'gene_id' and 'entropy' columns.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with an additional column:\n        - 'perplexity': effective number of isoforms per gene\n    \"\"\"\n    # compute perplexity as 2^entropy\n    df['perplexity'] = 2 ** df['entropy']\n    return df\n</code></pre>"},{"location":"api/#isoplex.compute_pi","title":"<code>compute_pi(df, gene_col=GENE_COL)</code>","text":"<p>Generate pi values (isoform ratios) from input expression column.</p>"},{"location":"api/#isoplex.compute_pi--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     DataFrame containing at least  and 'tpm'. gene_col : str     Column representing the gene (default: gene_id)"},{"location":"api/#isoplex.compute_pi--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame with an additional 'pi' column.</p> Source code in <code>src/isoplex/utils.py</code> <pre><code>def compute_pi(df, gene_col=GENE_COL):\n    \"\"\"\n    Generate pi values (isoform ratios) from input expression column.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame containing at least &lt;gene_col&gt; and 'tpm'.\n    gene_col : str\n        Column representing the gene (default: gene_id)\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with an additional 'pi' column.\n    \"\"\"\n    df['gene_tpm'] = df.groupby(gene_col)['tpm'].transform('sum')\n    df['pi'] = df['tpm'] / df['gene_tpm']\n    df['pi'] = df['pi'].fillna(0)\n    df = df.drop(columns='gene_tpm')\n    return df\n</code></pre>"},{"location":"api/#isoplex.compute_tpm","title":"<code>compute_tpm(df)</code>","text":"<p>Calculate TPM values from counts for a single-sample (bulk) dataframe and add as a new column to the dataframe.</p>"},{"location":"api/#isoplex.compute_tpm--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     Input dataframe containing 'counts'.</p>"},{"location":"api/#isoplex.compute_tpm--returns","title":"Returns","text":"<p>pd.DataFrame     DataFrame with a new column 'tpm' added.</p> Source code in <code>src/isoplex/utils.py</code> <pre><code>def compute_tpm(df):\n    \"\"\"\n    Calculate TPM values from counts for a single-sample (bulk) dataframe\n    and add as a new column to the dataframe.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Input dataframe containing 'counts'.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame with a new column 'tpm' added.\n    \"\"\"\n    df['tpm'] = df['counts'] / df['counts'].sum() * 1e6\n\n    return df\n</code></pre>"},{"location":"api/#isoplex.flatten_list","title":"<code>flatten_list(l)</code>","text":"<p>Flatten a list into 1 dimension.</p>"},{"location":"api/#isoplex.flatten_list--parameters","title":"Parameters","text":"<p>l : list</p> Source code in <code>src/isoplex/utils.py</code> <pre><code>def flatten_list(l):\n    \"\"\"\n    Flatten a list into 1 dimension.\n\n    Parameters\n    ----------\n    l : list\n    \"\"\"\n    return [j for i in l for j in i]\n</code></pre>"},{"location":"api/#isoplex.rename_sample_col","title":"<code>rename_sample_col(df, gene_col=GENE_COL, feature_col=TRANSCRIPT_COL, expression_type=EXP_COL)</code>","text":"Source code in <code>src/isoplex/utils.py</code> <pre><code>def rename_sample_col( df: pd.DataFrame,\n                       gene_col: str = GENE_COL,\n                       feature_col: str = TRANSCRIPT_COL,\n                       expression_type: str = EXP_COL):\n    \"\"\"\n    \"\"\"\n    sample_cols = [c for c in df.columns if c not in [gene_col,\n                                                      feature_col]]\n    if len(sample_cols)&gt;1:\n        raise ValueError('DF has more than one sample')\n\n    sample = sample_cols[0]\n    df.rename({sample:expression_type}, axis=1, inplace=True)\n    return df\n</code></pre>"},{"location":"api/#isoplex.validate_counts_input","title":"<code>validate_counts_input(df, gene_col=GENE_COL, feature_col=TRANSCRIPT_COL)</code>","text":"<p>Validate a wide-format expression DataFrame.</p> <p>In wide-format input, rows correspond to features (e.g. transcripts), columns (other than <code>gene_col</code> and <code>feature_col</code>) correspond to samples.</p>"},{"location":"api/#isoplex.validate_counts_input--parameters","title":"Parameters","text":"<p>df : pd.DataFrame     Wide-format expression table. gene_col : str     Column name identifying genes. feature_col : str     Column name identifying features (e.g., transcripts).</p>"},{"location":"api/#isoplex.validate_counts_input--raises","title":"Raises","text":"<p>KeyError     If either <code>gene_col</code> or <code>feature_col</code> is missing. ValueError     If:       - any sample column is non-numeric,       - there are missing gene or feature IDs,       - expression values contain negatives,       - all expression values sum to zero.</p> Source code in <code>src/isoplex/utils.py</code> <pre><code>def validate_counts_input(\n    df: pd.DataFrame,\n    gene_col: str = GENE_COL,\n    feature_col: str = TRANSCRIPT_COL\n) -&gt; bool:\n    \"\"\"\n    Validate a wide-format expression DataFrame.\n\n    In wide-format input, rows correspond to features (e.g. transcripts),\n    columns (other than `gene_col` and `feature_col`) correspond to samples.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        Wide-format expression table.\n    gene_col : str\n        Column name identifying genes.\n    feature_col : str\n        Column name identifying features (e.g., transcripts).\n\n    Raises\n    ------\n    KeyError\n        If either `gene_col` or `feature_col` is missing.\n    ValueError\n        If:\n          - any sample column is non-numeric,\n          - there are missing gene or feature IDs,\n          - expression values contain negatives,\n          - all expression values sum to zero.\n    \"\"\"\n\n    # Check that gene and feature columns exist\n    required_cols = [gene_col, feature_col]\n    missing = [c for c in required_cols if c not in df.columns]\n    if missing:\n        raise KeyError(f\"Missing required columns: {missing}\")\n\n    # Identify all putative sample columns\n    sample_cols = [c for c in df.columns if c not in required_cols]\n    if not sample_cols:\n        raise ValueError(\"No sample columns found in input.\")\n\n    # All sample columns must be numeric\n    non_numeric = [c for c in sample_cols\n                   if not pd.api.types.is_numeric_dtype(df[c])]\n    if non_numeric:\n        raise ValueError(\n            f\"Found non-numeric columns (likely metadata) in input: {non_numeric}\"\n        )\n\n    # Check for missing identifiers\n    if df[gene_col].isna().any():\n        raise ValueError(f\"Missing values in `{gene_col}` column.\")\n    if df[feature_col].isna().any():\n        raise ValueError(f\"Missing values in `{feature_col}` column.\")\n\n    # Check that expression values are non-negative and not all zero\n    expr_df = df[sample_cols]\n    if (expr_df &lt; 0).any().any():\n        raise ValueError(\"Expression values contain negative numbers.\")\n    if expr_df.sum().sum() &lt;= 0:\n        raise ValueError(\"Total expression counts sum to zero or less.\")\n\n    return True\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/fairliereese/isoplex/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>Isoform Perplexity could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/fairliereese/isoplex/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>isoplex</code> for local development.</p> <ol> <li>Fork the <code>isoplex</code> repo on GitHub.</li> <li>Clone your fork locally:</li> </ol> <pre><code>git clone git@github.com:your_name_here/isoplex.git\n</code></pre> <ol> <li>Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development:</li> </ol> <pre><code>mkvirtualenv isoplex\ncd isoplex/\npython setup.py develop\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass flake8 and the tests, including testing other Python versions with tox:</li> </ol> <pre><code>make lint\nmake test\n# Or\nmake test-all\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md.</li> <li>The pull request should work for Python 3.12 and 3.13. Tests run in GitHub Actions on every pull request to the main branch, make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<p>To run a subset of tests:</p> <pre><code>pytest tests.test_isoplex\n</code></pre>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run:</p> <pre><code>bump2version patch # possible: major / minor / patch\ngit push\ngit push --tags\n</code></pre> <p>You can set up a GitHub Actions workflow to automatically deploy your package to PyPI when you push a new tag.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please note that this project is released with a Contributor Code of Conduct. By participating in this project you agree to abide by its terms.</p>"},{"location":"input_data/","title":"Input data formatting","text":""},{"location":"input_data/#input-data-format","title":"Input Data Format","text":"<p>Both the CLI and Python API work with the same underlying table structure. The CLI reads from TSV/CSV files, while the API can take a <code>pandas.DataFrame</code> directly.</p> <p>Every table must include:</p> <ol> <li> <p>Gene column    Contains the gene identifier for each row.    The column name can be anything; it is specified when running the tool.</p> </li> <li> <p>Feature column    Contains the feature identifier (for example, isoform or transcript ID).    The column name is also user-specified.</p> </li> <li> <p>Expression data    One or more numeric columns containing either raw counts or normalized TPM values.    The type (counts vs TPM) is specified at runtime.</p> </li> </ol>"},{"location":"input_data/#single-sample-format","title":"Single-Sample Format","text":"<p>For datasets representing one sample, include exactly one numeric expression column.</p> <p>Example:</p> <pre><code>gene_id    transcript_id    sample1\nG1         T1               100\nG1         T2                50\nG2         T3                30\nG2         T4                 0\n</code></pre>"},{"location":"input_data/#multi-sample-format","title":"Multi-Sample Format","text":"<p>For datasets with multiple samples, include one column per sample, and all must be numeric.</p> <p>Example:</p> <pre><code>gene_id    transcript_id    sample1    sample2    sample3\nG1         T1               100        80         90\nG1         T2                50        20         30\nG2         T3                10         5          8\nG2         T4                 0         2          4\n</code></pre>"},{"location":"input_data/#notes","title":"Notes","text":"<p>Column names for gene, feature, and samples are flexible \u2014 you specify them when using either the CLI or the API.</p> <p>All expression columns must contain only non-negative, numeric values.</p> <p>For API usage, simply pass a properly structured pandas.DataFrame; no file format or separator concerns apply.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install Isoform Perplexity, run this command in your terminal:</p> <pre><code>uv add isoplex\n</code></pre> <p>Or if you prefer to use <code>pip</code>:</p> <pre><code>pip install isoplex\n</code></pre>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source files for Isoform Perplexity can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/fairliereese/isoplex\n</code></pre> <p>Or download the tarball:</p> <pre><code>curl -OJL https://github.com/fairliereese/isoplex/tarball/main\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>cd isoplex\nuv pip install .\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p><code>isoplex</code> allows you to perform the computations either from within Python, or using the command line. There are two modes: single-sample (global) or multi-sample. If you have a multi-sample expression matrix, please use the corresponding option; global-level metrics will also be provided!</p> <p>See also the input data format specifications.</p>"},{"location":"usage/#python","title":"Python","text":"<p>Compute single-sample statistics:</p> <pre><code>import pandas as pd\nimport isoplex\n\ndf = pd.read_csv('my_isoform_expression_matrix.tsv', sep='\\t')\n\nglobal_perplexity = isoplex.compute_global_isoform_metrics(df,\n                              gene_col='gene_id',\n                              feature_col='transcript_id',\n                              expression_type='tpm')\n</code></pre> <p>Compute multi-sample statistics, as well as global statistics:</p> <pre><code>import pandas as pd\nimport isoplex\n\ndf = pd.read_csv('my_isoform_expression_matrix.tsv', sep='\\t')\n\nsample_perplexity, global_perplexity = isoplex.compute_multi_sample_isoform_metrics(df,\n                              gene_col='gene_id',\n                              feature_col='transcript_id',\n                              expression_type='tpm')\n</code></pre> <p>See more details about the Python functions in the API docs.</p>"},{"location":"usage/#cli","title":"CLI","text":"<p>Compute single-sample statistics:</p> <pre><code>Usage: isoplex global-metrics [OPTIONS] INPUT_FILE OUTPUT_FILE\n\nCompute global isoform (or other feature) diversity metrics for a single-sample dataset.\n\nArguments:\n  INPUT_FILE        Filename to input expression table (CSV or TSV).  [required]\n  OUTPUT_FILE       Filename to save the output file.                [required]\n\nOptions:\n  --gene-col TEXT          Column name for gene IDs. [default: gene_id]\n  --feature-col TEXT       Column name for isoform/feature IDs. [default: transcript_id]\n  --expression-type TEXT   Expression type in table: 'counts' or 'tpm'. [default: counts]\n  --sep TEXT               Delimiter for input/output files. Use ',' for CSV. [default: \\t]\n  --help                   Show this message and exit.\n</code></pre> <p>Compute multi-sample statistics, as well as global statistics:</p> <pre><code>Usage: isoplex multi-sample-metrics [OPTIONS] INPUT_FILE OUTPUT_SAMPLE_FILE\n                                    OUTPUT_GLOBAL_FILE\n\nCompute sample-level and global isoform (or other feature) diversity\nmetrics for a single-sample dataset.\n\nArguments:\n  INPUT_FILE               Filename to input expression table (CSV or TSV).\n  OUTPUT_SAMPLE_FILE       Filename to save the sample-level output file.\n  OUTPUT_GLOBAL_FILE       Filename to save the global-level output file.\n\nOptions:\n  --gene-col TEXT          Column name for gene IDs. [default: gene_id]\n  --feature-col TEXT       Column name for isoform/feature IDs. [default:\n                           transcript_id]\n  --expression-type TEXT   Expression type in table: 'counts' or 'tpm'.\n                           [default: counts]\n  --sep TEXT               Delimiter for input/output files. Use ',' for CSV.\n                           [default: \\t]\n  --help                   Show this message and exit.\n</code></pre>"}]}